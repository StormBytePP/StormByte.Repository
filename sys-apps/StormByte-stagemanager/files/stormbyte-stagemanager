#! /bin/bash

# This script can run standalone if its config and functions are in its folder
workdir="${0%/*}"
if [ -f "${workdir}/functions.sh" ]; then
	source "${workdir}/functions.sh"
elif [ -f "/lib/StormByte/functions.sh" ]; then
	source "/lib/StormByte/functions.sh"
else
	echo "Can't find functions.sh file in neither current directory neither /lib/StormByte"
	exit 1
fi

loadConfig

version="1.1.2"
current_folder=`pwd`
file_list=(`find "${TARBALL_FOLDER}" -type f \( -iname "*.tar.gz" -o -iname "*.tgz" -o -iname "*.tar.bz2" -o -iname "*.tbz2" -o -iname "*.tar.xz" -o -iname "*.txz" -o -iname "*.tar.zstd" -o -iname "*.tzd" \)`)
tarball_filename_fullpath=""
tarball_filename=""
tarball_extension=""
tarball=""
tarball_output=""
compress=""
extract=""
gtar="tar -I 'pigz -9'"
btar="tar -I 'pbzip2 -9'"
xtar="tar -I 'pxz -9eT0'"
zdtar="tar -I 'pzstd -19 -q'"
command="${parameters[0]}"
tmp_folder=""
lockfile=""
output_folder=""
available_commands=(list use rebase convert export delete rename download copy help)
available_compression_formats=( gzip bzip2 xz zstd )
available_compression_extensions=( tar.gz tgz tar.bz2 tbz2 tar.xz txz tar.zstd tzd )

function header() {
	echo "StormByte Gentoo Stage Manager Version ${version}"
	echo "Author: David C. Manuelda a.k.a StormByte <StormByte@gmail.com>"
	echo ""
}

function usage() {
	echo "This script will handle a gentoo chroot from a compressed tarball, it will mount all the needed points, chroot to it, clean, and make changes to compressed file again"
	echo "Configuration is located in /etc/conf.d/stormbyte-stagemanager.conf"
	echo "Usage is $self <command> <arguments>"
	echo "Available commands are: ${available_commands[*]}"
	echo "For more detailed help, use $self help <command> or $self help compression for more information about compression"
	echo "See configuration file $config_file for more tweaking options"
}

function helpList() {
	echo "Usage: $self list"
	echo "This command will list the files in the folder specified which is ${TARBALL_FOLDER}, showing index number, size and filename."
	echo "Use that index name to refer to the file in other commands"
}

function helpUse() {
	echo "Usage: $self use <index>"
	echo "This command will use file specified as index (see list command) for configuring and entering a chroot"
}

function helpRebase() {
	echo "Usage: $self rebase <index> <new_file_name>"
	echo "This command is similar to use command, but before entering chroot, it copies file specified from index (see list command) to destination folder set in $config under new_file_name."
	echo "Compression method is determined by the extension, see $self help compression for more details"
}

function helpConvert() {
	echo "Usage: $self convert <index> <compression_format>"
	echo "This command will copy file specified by index and recompress to selected compression_format, an error will be raised if target filename determined by compression already exists"
	echo "For more info about compression use $self help compression"
}

function helpExport() {
	echo "Usage: $self export <index> <destination_folder> <compression_format>"
	echo "This command is similar to convert, but it allows to specify a destination folder for the new file. This folder has to exist or an error will be raised"
}

function helpDelete() {
	echo "Usage: $self delete <index>"
	echo "This command will delete a file specified by its index (see list command)"
}

function helpRename() {
	echo "Usage: $self rename <index> <new_file_name>"
	echo "This command allows renaming a file specified by index (see list command) to a new_file_name under the same folder."
}

function helpCompression() {
	echo "This utility uses compression for keeping storage of its files, some times, depending on the command, compression is determined by the file extension or by the name of the compressor algorithm"
	echo "Available extensions are: ${available_compression_extensions[*]}"
	echo "Available compression formats are: ${available_compression_formats[*]}"
}

function helpDownload() {
	echo "Usage: $self download <arch> <profile>"
	echo "This command will download a stage3 for selected arch and profile. If profile is not specified, a default one will be chosen"
	echo "Available arches are i486, i686, amd64 and x32"
	echo "Available profiles depends on selected arch:"
	echo ""
	echo "i486:"
	echo "  * default"
	echo ""
	echo "i686:"
	echo "  * default"
	echo "  * hardened"
	echo "  * systemd"
	echo "  * uclibc-hardened"
	echo "  * uclibc-vanilla"
	echo ""
	echo "amd64:"
	echo "  * default (multilib)"
	echo "  * hardened"
	echo "  * nomultilib"
	echo "  * systemd"
	echo "  * hardened+nomultilib"
	echo "  * hardened-selinux"
	echo "  * hardened-selinux+nomultilib"
	echo "  * uclibc-hardened"
	echo "  * uclibc-vanilla"
	echo ""
	echo "x32:"
	echo "  * default"
}

function helpCopy() {
	echo "Usage: $self copy <index> <new_filename>"
	echo "This command will copy a file identified by its index (see list command) to new_filename under the same path"
}

function checkVars() {
	local errors=0
	if [ -z "${STORAGE_SYSTEM}" ] || [ "${STORAGE_SYSTEM}" != "zram" ] && [ "${STORAGE_SYSTEM}" != "tmpfs" ] && [ "${STORAGE_SYSTEM}" != "folder" ]; then
		echo "STORAGE_SYSTEM variable is not set, is empty or contains an invalid value!"
		errors=1
	fi
	# We only check for STORAGE_SIZE if zram or tmpfs is set to be used
	if [ "${STORAGE_SYSTEM}" = "zram" ] || [ "${STORAGE_SYSTEM}" = "tmpfs" ]; then
		local re="^[0-9]+[MG]$" # For checking storage size
		if ! [[ "${STORAGE_SIZE}" =~ $re ]]; then
			echo "STORAGE_SIZE is either empty or invalid, check if its value is correct!"
			errors=1
		fi
	fi
	if [ -z "${TARBALL_FOLDER}" ]; then
		echo "TARBALL_FOLDER variable is not set or empty!"
		errors=1
	fi
	if [ "${errors}" -eq 1 ]; then
		exit 1
	fi
}

function setOutputFolder() {
	if [ "$#" -eq 0 ]; then
		output_folder="${TARBALL_FOLDER}"
	else
		output_folder="$1"
		if [ ! -d "${output_folder}" ]; then
			echo "Output folder ${output_folder} does not exist!"
			exit 1
		fi
	fi
}

function setDecompression() {
	case "$1" in
		tar.gz|tgz|gzip)
			extract=${gtar}
			;;

		tar.bz2|tbz2|bzip2)
			extract=${btar}
			;;

		tar.xz|txz|xz)
			extract=${xtar}
			;;

		tar.zstd|tzd|zstd)
			extract=${zdtar}
			;;

		*)
			echo "Error: compression method $1 unknown"
			exit 1
			;;
	esac
}

function setCompression() {
	case "$1" in
		tar.gz|tgz|gzip)
			compress=${gtar}
			tarball_output="${tarball_filename}.tgz"
			;;

		tar.bz2|tbz2|bzip2)
			compress=${btar}
			tarball_output="${tarball_filename}.tbz2"
			;;

		tar.xz|txz|xz)
			compress=${xtar}
			tarball_output="${tarball_filename}.txz"
			;;

		tar.zstd|tzd|zstd)
			compress=${zdtar}
			tarball_output="${tarball_filename}.tzd"
			;;

		*)
			echo "Error: compression method $1 unknown"
			exit 1
			;;
	esac
}

function mountSystem() {
	handleCommand "mount -t proc /proc ${tmp_folder}/proc && mount --rbind /dev ${tmp_folder}/dev && mount --make-rslave ${tmp_folder}/dev && mount --rbind /sys ${tmp_folder}/sys && mount --make-rslave ${tmp_folder}/sys" "Mounting system structures"
}

function unmountSystem() {
	cd "${current_folder}"
	handleCommand "umount -R ${tmp_folder}/proc && umount -R ${tmp_folder}/dev && umount -R ${tmp_folder}/sys && rm -Rf {tmp_folder}/tmp/* && rm -f ${tmp_folder}/root/.bash_history" "Unmounting system structures and cleaning"
}

function setAndCheckFile() {
	# If this received a parameter then will ignore selected index and will use the file provided in parameter
	if [ "$#" -eq 0 ]; then
		local re='^[0-9]+$'
		if [[ ${parameters[1]} =~ $re ]] ; then
			tarball_filename_fullpath="${file_list[${parameters[1]}]}"
		else
			echo "Parameter should be an integer for the index"
			exit 1
		fi
	else
		tarball_filename_fullpath="$1"
	fi

	if [ ! -f "${tarball_filename_fullpath}" ]; then
		echo "File $tarball_filename_fullpath does not exist"
		exit 1
	fi

	tarball=`basename "${tarball_filename_fullpath}"`
	tarball_filename="${tarball%.*}"
	tarball_extension="${tarball##*.}"
	setCompression ${tarball_extension}
	setDecompression ${tarball_extension}
	lockfile="/tmp/.${tarball}.lock"
	if [ -z "${tarball_extension}" ]; then
		echo "Tarball extension is empty, did you specified correctly the file name?"
		exit 1
	fi
}

function checkFileCopy() {
	# Received 2 parameters: origin destination
	origin="${TARBALL_FOLDER}/`basename $1`"
	destination="${TARBALL_FOLDER}/`basename $2`"
	if [ ! -f "$origin" ]; then
		echo "Origin file `basename $origin` does not exist"
		exit 1
	elif [ -f "$destination" ]; then
		echo "Destination file `basename $destination` already exist"
		exit 1
	fi
}

function createTMPFolder() {
	handleCommand "tmp_folder=`mktemp -d`" "Creating temporary folder"
}

function deleteTMPFolder() {
	handleCommand "rm -Rf ${tmp_folder}" "Deleting temporary folder"
}

function mountTEMP() {
	case "${STORAGE_SYSTEM}" in
		folder)
			mountFOLDER
			;;
		tmpfs)
			mountTMPFS
			;;
		zram)
			mountZRAM
			;;
	esac
}

function unmountTEMP() {
	case "${STORAGE_SYSTEM}" in
		folder)
			unmountFOLDER
			;;
		tmpfs)
			unmountTMPFS
			;;
		zram)
			unmountZRAM
			;;
	esac
}

function mountFOLDER() {
	mkdir -p "${tmp_folder}"
}

function mountZRAM() {
	mkdir -p "${tmp_folder}"
	handleCommand "echo 1 > /sys/block/zram0/reset" "Resetting ZRAM..."
	handleCommand "echo '${STORAGE_SIZE}' > /sys/block/zram0/disksize" "Setting ZRAM size to ${STORAGE_SIZE}..."
	handleCommand "mkfs.btrfs /dev/zram0" "Initializing ZRAM with btrfs..."
	handleCommand "mount /dev/zram0 '${tmp_folder}' -o noatime,compress=zstd" "Mounting ZRAM storage"
}

function mountTMPFS() {
	mkdir -p "${tmp_folder}"
	handleCommand "mount -t tmpfs -o size=${STORAGE_SIZE} tmpfs ${tmp_folder} -o nr_inodes=0" "Mounting tmpfs storage"
}

function unmountFOLDER() {
	cd "${current_folder}"
	# This is a NO OP function as it will be just deleted later
}

function unmountZRAM() {
	cd "${current_folder}"
	handleCommand "umount -R ${tmp_folder}" "Unmounting ZRAM storage"
	handleCommand "echo 1 > /sys/block/zram0/reset" "Deactivating ZRAM..."
}

function unmountTMPFS() {
	cd "${current_folder}"
	handleCommand "umount -R ${tmp_folder}" "Unmounting tmpfs storage"
}

function extractArchive() {
	cd "${tmp_folder}"
	handleCommand "${extract} -xpf ${tarball_filename_fullpath} --xattrs-include='*.*' --numeric-owner" "Extracting system files from ${tarball}"
}

function saveChanges() {
	local reply=""
	while [[ ! $reply =~ ^[YyNn]$ ]]; do
		read -p "Do you want to save the changes? [Y/N]: " -r
		reply=$REPLY
	done
	if [[ $reply =~ ^[Yy]$ ]]; then
		compressArchive
	fi
}

function compressArchive() {
	rm -Rf "${tmp_folder}"/tmp/*
	cd "${tmp_folder}"
	handleCommand "${compress} -cpf ${output_folder}/.${tarball_output}.compress . --xattrs-include='*.*' --numeric-owner" "Compressing system files to ${tarball_output}"
	mv "${output_folder}/.${tarball_output}.compress" "${output_folder}/${tarball_output}"
}

function doChroot() {
	echo "Entering chroot, don't forget to run env-update && . /etc/profile"
	chroot "${tmp_folder}" "/bin/bash"
}

function doList() {
	if [ -z "${file_list}" ]; then
		echo "File list is empty, check ${TARBALL_FOLDER} contents!"
		exit 1
	fi
	echo -e "Index\tSize\t\tFile Name"
	for i in "${!file_list[@]}"; do
		tarball_filename=`basename ${file_list[$i]}`
		local size=`ls -s --block-size=1048576 "${file_list[$i]}" | cut -d' ' -f1`
		echo -en "$i\t${size} MiB"
		if [ "${#size}" -gt 3 ]; then
			echo -en "\t"
		else
			echo -en "\t\t"
		fi
		echo -n "${tarball_filename}"
		if [ -f "/tmp/.${tarball_filename}.lock" ]; then
			echo " (in use)"
		else
			echo ""
		fi
	done
}

doLock() {
	if [ -f "${lockfile}" ]; then
		echo "Another instance is running using file ${lockfile}"
		echo "If this is an error manually delete ${lockfile} file"
		exit 1
	fi
	handleCommand "touch ${lockfile}" "Setting lockfile"
}

doUnlock() {
	handleCommand "rm -f ${lockfile}" "Removing lockfile"
}

function doUse() {
	# If no parameter if received, it will autodetect from script arguments, otherwise it will use provided filename as parameter
	setAndCheckFile "$@"
	doLock
	createTMPFolder
	mountTEMP
	extractArchive
	mountSystem
	doChroot
	unmountSystem
	saveChanges
	unmountTEMP
	deleteTMPFolder
	doUnlock
}

function doConvert() {
	setAndCheckFile
	setCompression ${parameters[2]}
	setDecompression ${tarball_extension}
	doLock
	createTMPFolder
	mountTEMP
	extractArchive
	compressArchive
	unmountTEMP
	deleteTMPFolder
	doUnlock
}

function doExport() {
	setOutputFolder "${parameters[2]}"
	setAndCheckFile
	setCompression ${parameters[3]}
	setDecompression ${tarball_extension}
	tarball_output="${tarball_output%.*}-`date +%Y%m%d`.${tarball_output##*.}"
	if [ -f "${output_folder}/${tarball_output}" ]; then
		local reply=""
		while [[ ! $reply =~ ^[YyNn]$ ]]; do
			read -p "File ${tarball_output} already exists, overwrite? [Y/N]: " -r
			reply=$REPLY
		done
		if [[ $reply =~ ^[Nn]$ ]]; then
			echo "No action was done"
			exit 1
		fi
	fi
	doLock
	createTMPFolder
	mountTEMP
	extractArchive
	compressArchive
	unmountTEMP
	deleteTMPFolder
	doUnlock
}

function doDelete() {
	setAndCheckFile
	doLock
	handleCommand "rm -f ${tarball_filename_fullpath}" "Deleting file ${tarball}"
	doUnlock
}

function doRename() {
	local new_filename=`basename "${parameters[2]}"`
	setAndCheckFile
	checkFileCopy "${tarball_filename_fullpath}" "${new_filename}"
	doLock
	handleCommand "mv '${tarball_filename_fullpath}' '${TARBALL_FOLDER}/${new_filename}'" "Renaming ${tarball} to ${new_filename}"
	doUnlock
}

function doRebase() {
	doCopy
	doUse "${TARBALL_FOLDER}/${new_filename}"
}

function checkDownloadParameters() {
	arch="${parameters[1]}"
	profile="${parameters[2]}"
	profile_error=0
	arch_error=0
	if [ -z "${profile}" ]; then
		profile="default"
	fi
	case "${arch}" in
		i486)
			stage_base_url="http://distfiles.gentoo.org/releases/x86/autobuilds"
			case "${profile}" in
				default)
					stage_info_file="latest-stage3-i486.txt"
					;;
				*)
					profile_error=1
					;;
			esac
			;;
		i686)
			stage_base_url="http://distfiles.gentoo.org/releases/x86/autobuilds"
			case "${profile}" in
				default)
					stage_info_file="latest-stage3-i686.txt"
					;;
				hardened)
					stage_info_file="latest-stage3-i686-hardened.txt"
					;;
				systemd)
					stage_info_file="latest-stage3-i686-systemd.txt"
					;;
				uclibc-hardened)
					stage_info_file="latest-stage3-i686-uclibc-hardened.txt	"
					;;
				uclibc-vanilla)
					stage_info_file="latest-stage3-i686-uclibc-vanilla.txt"
					;;
				*)
					profile_error=1
					;;
			esac
			;;
		amd64)
			stage_base_url="http://distfiles.gentoo.org/releases/amd64/autobuilds"
			case "${profile}" in
				default)
					stage_info_file="latest-stage3-amd64.txt"
					;;
				hardened)
					stage_info_file="latest-stage3-amd64-hardened.txt"
					;;
				nomultilib)
					stage_info_file="latest-stage3-amd64-nomultilib.txt"
					;;
				systemd)
					stage_info_file="latest-stage3-amd64-systemd.txt"
					;;
				hardened+nomultilib)
					stage_info_file="latest-stage3-amd64-hardened+nomultilib.txt"
					;;
				hardened-selinux)
					stage_info_file="latest-stage3-amd64-hardened-selinux.txt"
					;;
				hardened-selinux+nomultilib)
					stage_info_file="latest-stage3-amd64-hardened-selinux+nomultilib.txt"
					;;
				uclibc-hardened)
					stage_info_file="latest-stage3-amd64-uclibc-hardened.txt"
					;;
				uclibc-vanilla)
					stage_info_file="latest-stage3-amd64-uclibc-vanilla.txt"
					;;
				*)
					profile_error=1
					;;
			esac
			;;
		x32)
			stage_base_url="http://distfiles.gentoo.org/releases/amd64/autobuilds"
			case "${profile}" in
				default)
					stage_info_file="latest-stage3-x32.txt"
					;;
				*)
					profile_error=1
					;;
			esac
			;;
		*)
			arch_error=1
			;;
	esac

	if [ "${arch_error}" -eq 1 ]; then
		displayError "Arch '${arch}' is not available for download, consult $self help download"
	fi
	if [ "${profile_error}" -eq 1 ]; then
		displayError "Profile '${profile}' is not available for arch '${arch}', consult $self help download"
	fi		
}

function doDownload() {
	arch="${parameters[1]}"
	profile="${parameters[2]}"
	if [ -z "${profile}" ]; then
		profile="default"
	fi

	checkDownloadParameters
	createTMPFolder
	handleCommand "curl -o ${tmp_folder}/${stage_info_file} ${stage_base_url}/${stage_info_file}" "Downloading stage information"
	stage_file="`sed -r -e 's/(^[^#]*$)/\1/g; /^#.*$/d;' ${tmp_folder}/${stage_info_file} | awk '{print $1}'`"
	handleCommand "curl -o ${tmp_folder}/`basename ${stage_file}` ${stage_base_url}/${stage_file}" "Downloading `basename ${stage_file}`"
	handleCommand "mv '${tmp_folder}/`basename ${stage_file}`' '${TARBALL_FOLDER}/`basename ${stage_file}`'" "Moving stage data from temporary folder"
	deleteTMPFolder
	echo "`basename ${stage_file}` downloaded to ${TARBALL_FOLDER}"
}

function doCopy() {
	new_filename=`basename "${parameters[2]}"`	
	setAndCheckFile
	checkFileCopy "${tarball_filename_fullpath}" "${new_filename}"
	handleCommand "cp '${tarball_filename_fullpath}' '${TARBALL_FOLDER}/${new_filename}'" "Rebasing ${tarball} to ${new_filename}"
}

function doHelp() {
	case "${parameters[1]}" in
		list)
			helpList
			;;
		use)
			helpUse
			;;
		convert)
			helpConvert
			;;
		export)
			helpExport
			;;
		delete)
			helpDelete
			;;
		rename)
			helpRename
			;;
		rebase)
			helpRebase
			;;
		download)
			helpDownload
			;;
		compression)
			helpCompression
			;;
		copy)
			helpCopy
			;;
		*)
			usage
			;;
	esac
}
	

function doInit() {
	header
	checkVars
	setOutputFolder

	case $command in
		list)
			doList
			;;
		use)
			doUse
			;;
		convert)
			doConvert
			;;
		export)
			doExport
			;;
		delete)
			doDelete
			;;
		rename)
			doRename
			;;
		rebase)
			doRebase
			;;
		download)
			doDownload
			;;
		copy)
			doCopy
			;;
		help)
			doHelp
			;;
		*)
			usage
			exit 1
	esac
	exit 0
}

doInit

