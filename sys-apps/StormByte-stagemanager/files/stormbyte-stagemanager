#! /bin/bash

source "/etc/conf.d/stormbyte-stagemanager.conf"

version="2.1.3"
current_folder=`pwd`
file_list=(`find "${TARBALL_FOLDER}" -type f \( -iname "*.tar.gz" -o -iname "*.tgz" -o -iname "*.tar.bz2" -o -iname "*.tbz2" -o -iname "*.tar.xz" -o -iname "*.txz" \)`)
tarball_filename_fullpath=""
tarball_filename=""
tarball_extension=""
tarball=""
tarball_output=""
compress=""
extract=""
gtar="tar -I 'pigz -${COMPRESSION_LEVEL}'"
btar="tar -I 'pbzip2 -${COMPRESSION_LEVEL}'"
xtar="tar -I 'pxz -${COMPRESSION_LEVEL}eT0'"
command="$1"
arguments=("${@:2}")
tmp_folder=""
lockfile=""
output_folder=""

function header() {
	echo "StormByte Gentoo Stage Manager Version ${version}"
	echo "Author: David C. Manuelda a.k.a StormByte <StormByte@gmail.com>"
	echo ""
}

function usage() {
	echo "This script will handle a gentoo chroot from a compressed tarball, it will mount all the needed points, chroot to it, clean, and make changes to compressed file again"
	echo "Configuration is located in /etc/conf.d/stormbyte-stagemanager.conf"
	echo "Usage is $0 <command> <arguments>"
	echo "Where command is"
	echo " * list - will list all usable files"
	echo " * use <index> - Uses a filename from list (or its index) for chrooting"
	echo " * rebase <index> <new_filename> - Same than above but it makes a copy first and will use that copy for chroot"
	echo " * convert <index> <compression_format> - Converts to another compression format, accepted values are: gzip, bzip2 and xz"
	echo " * export <index> <destination_folder> <compression_format> - Same than above but saving in a custom folder and adding YYYYmmdd to the filename"
	echo " * delete <index> - Permanently deletes the file"
	echo " * rename <index> <newname> - Renames the file"
	echo " * help - Show this help message"
	echo "See configuration file for more tweaking options"
}

function handleCommand() {
	# This helper will execute $1 outputting $2 as first text along with OK or ERROR if it failed
	# Example
	# handleCommand 'mount -t proc /proc "${tmp_folder}/proc"' "Mounting system..."
	echo -n "${2} ... "
	eval $1 > /dev/null 2>&1
	
	if [ $? -eq 0 ]; then
		echo "OK"
	else
		echo "ERROR in command '$1'"
		cd "${current_folder}"
		exit 1
	fi
}

function checkVars() {
	local errors=0
	local re='^[1-9]$' # For checking compression level
	if [ -z "${COMPRESSION_LEVEL}" ] || ! [[ "${COMPRESSION_LEVEL}" =~ $re ]]; then
		echo "COMPRESSION_LEVEL is either empty or invalid, check if it is in a range between 1 and 9!"
		errors=1
	fi
	if [ -z "${TMPFS_SIZE}" ]; then
		echo "TMPFS_SIZE variable is not set or empty!"
		errors=1
	fi
	if [ -z "${TARBALL_FOLDER}" ]; then
		echo "TARBALL_FOLDER variable is not set or empty!"
		errors=1
	fi
	if [ "${errors}" -eq 1 ]; then
		exit 1
	fi
}

function setOutputFolder() {
	if [ "$#" -eq 0 ]; then
		output_folder="${TARBALL_FOLDER}"
	else
		output_folder="$1"
		if [ ! -d "${output_folder}" ]; then
			echo "Output folder ${output_folder} does not exist!"
			exit 1
		fi
	fi
}

function setDecompression() {
	case "$1" in
		tar.gz|tgz|gzip)
			extract=${gtar}
			;;

		tar.bz2|tbz2|bzip2)
			extract=${btar}
			;;

		tar.xz|txz|xz)
			extract=${xtar}
			;;

		*)
			echo "Error: compression method $1 unknown"
			exit 1
			;;
	esac
}

function setCompression() {
	case "$1" in
		tar.gz|tgz|gzip)
			compress=${gtar}
			tarball_output="${tarball_filename}.tgz"
			;;

		tar.bz2|tbz2|bzip2)
			compress=${btar}
			tarball_output="${tarball_filename}.tbz2"
			;;

		tar.xz|txz|xz)
			compress=${xtar}
			tarball_output="${tarball_filename}.txz"
			;;

		*)
			echo "Error: compression method $1 unknown"
			exit 1
			;;
	esac
}

function mountSystem() {
	handleCommand "mount -t proc /proc ${tmp_folder}/proc && mount --rbind /dev ${tmp_folder}/dev && mount --make-rslave ${tmp_folder}/dev && mount --rbind /sys ${tmp_folder}/sys && mount --make-rslave ${tmp_folder}/sys" "Mounting system structures"
}

function unmountSystem() {
	cd "${current_folder}"
	handleCommand "umount -R ${tmp_folder}/proc && umount -R ${tmp_folder}/dev && umount -R ${tmp_folder}/sys && rm -Rf {tmp_folder}/tmp/* && rm -f ${tmp_folder}/root/.bash_history" "Unmounting system structures and cleaning"
}

function setAndCheckFile() {
	# If this received a parameter then will ignore selected index and will use the file provided in parameter
	if [ "$#" -eq 0 ]; then
		local re='^[0-9]+$'
		if [[ ${arguments[0]} =~ $re ]] ; then
			tarball_filename_fullpath="${file_list[${arguments[0]}]}"
		else
			echo "Parameter should be an integer for the index"
			exit 1
		fi
	else
		tarball_filename_fullpath="$1"
	fi

	if [ ! -f "${tarball_filename_fullpath}" ]; then
		echo "File $tarball_filename_fullpath does not exist"
		exit 1
	fi

	tarball=`basename "${tarball_filename_fullpath}"`
	tarball_filename="${tarball%.*}"
	tarball_extension="${tarball##*.}"
	setCompression ${tarball_extension}
	setDecompression ${tarball_extension}
	lockfile="/tmp/.${tarball}.lock"
	if [ -z "${tarball_extension}" ]; then
		echo "Tarball extension is empty, did you specified correctly the file name?"
		exit 1
	fi
}

function checkFileCopy() {
	# Received 2 parameters: origin destination
	origin="${TARBALL_FOLDER}/`basename $1`"
	destination="${TARBALL_FOLDER}/`basename $2`"
	if [ ! -f "$origin" ]; then
		echo "Origin file `basename $origin` does not exist"
		exit 1
	elif [ -f "$destination" ]; then
		echo "Destination file `basename $destination` already exist"
		exit 1
	fi
}

function createTMPFolder() {
	handleCommand "tmp_folder=`mktemp -d`" "Creating temporary folder"
}

function deleteTMPFolder() {
	handleCommand "rm -Rf ${tmp_folder}" "Deleting temporary folder"
}

function mountTMPFS() {
	mkdir -p "${tmp_folder}"
	handleCommand "mount -t tmpfs -o size=${TMPFS_SIZE} tmpfs ${tmp_folder}" "Mounting tmpfs storage"
}

function unmountTMPFS() {
	cd "${current_folder}"
	handleCommand "umount -R ${tmp_folder}" "Unmounting tmpfs storage"
}

function extractArchive() {
	cd "${tmp_folder}"
	handleCommand "${extract} -xpf ${tarball_filename_fullpath} --xattrs-include='*.*' --numeric-owner" "Extracting system files from ${tarball}"
}

function saveChanges() {
	local reply=""
	while [[ ! $reply =~ ^[YyNn]$ ]]; do
		read -p "Do you want to save the changes? [Y/N]: " -r
		reply=$REPLY
	done
	if [[ $reply =~ ^[Yy]$ ]]; then
		compressArchive
	fi
}

function compressArchive() {
	rm -Rf "${tmp_folder}"/tmp/*
	cd "${tmp_folder}"
	handleCommand "${compress} -cpf ${output_folder}/.${tarball_output} . --xattrs-include='*.*' --numeric-owner" "Compressing system files to ${tarball_output}"
	mv "${output_folder}/.${tarball_output}" "${output_folder}/${tarball_output}"
}

function doChroot() {
	echo "Entering chroot, don't forget to run env-update && . /etc/profile"
	chroot "${tmp_folder}" "/bin/bash"
}

function doList() {
	if [ -z "${file_list}" ]; then
		echo "File list is empty, check ${TARBALL_FOLDER} contents!"
		exit 1
	fi
	echo -e "Index\tSize\t\tFile Name"
	for i in "${!file_list[@]}"; do
		tarball_filename=`basename ${file_list[$i]}`
		echo -en "$i\t`ls -s --block-size=1048576 ${file_list[$i]} | cut -d' ' -f1` MiB\t\t${tarball_filename}"
		if [ -f "/tmp/.${tarball_filename}.lock" ]; then
			echo " (in use)"
		else
			echo ""
		fi
	done
}

doLock() {
	if [ -f "${lockfile}" ]; then
		echo "Another instance is running using file ${lockfile}"
		echo "If this is an error manually delete ${lockfile} file"
		exit 1
	fi
	handleCommand "touch ${lockfile}" "Setting lockfile"
}

doUnlock() {
	handleCommand "rm -f ${lockfile}" "Removing lockfile"
}

function doUse() {
	# If no parameter if received, it will autodetect from script arguments, otherwise it will use provided filename as parameter
	setAndCheckFile "$@"
	doLock
	createTMPFolder
	mountTMPFS
	extractArchive
	mountSystem
	doChroot
	unmountSystem
	saveChanges
	unmountTMPFS
	deleteTMPFolder
	doUnlock
}

function doConvert() {
	setAndCheckFile
	setCompression ${arguments[1]}
	setDecompression ${tarball_extension}
	doLock
	createTMPFolder
	mountTMPFS
	extractArchive
	compressArchive
	unmountTMPFS
	deleteTMPFolder
	doUnlock
}

function doExport() {
	setOutputFolder "${arguments[1]}"
	setAndCheckFile
	setCompression ${arguments[2]}
	setDecompression ${tarball_extension}
	tarball_output="${tarball_output%.*}-`date +%Y%m%d`.${tarball_output##*.}"
	if [ -f "${output_folder}/${tarball_output}" ]; then
		local reply=""
		while [[ ! $reply =~ ^[YyNn]$ ]]; do
			read -p "File ${tarball_output} already exists, overwrite? [Y/N]: " -r
			reply=$REPLY
		done
		if [[ $reply =~ ^[Nn]$ ]]; then
			echo "No action was done"
			exit 1
		fi
	fi
	doLock
	createTMPFolder
	mountTMPFS
	extractArchive
	compressArchive
	unmountTMPFS
	deleteTMPFolder
	doUnlock
}

function doDelete() {
	setAndCheckFile
	doLock
	handleCommand "rm -f ${tarball_filename_fullpath}" "Deleting file ${tarball}"
	doUnlock
}

function doRename() {
	local new_filename=`basename "${arguments[1]}"`
	setAndCheckFile
	checkFileCopy "${tarball_filename_fullpath}" "${new_filename}"
	doLock
	handleCommand "mv '${tarball_filename_fullpath}' '${TARBALL_FOLDER}/${new_filename}" "Renaming ${tarball} to ${new_filename}"
	doUnlock
}

function doRebase() {
	local new_filename=`basename "${arguments[1]}"`	
	setAndCheckFile
	checkFileCopy "${tarball_filename_fullpath}" "${new_filename}"
	handleCommand "cp '${tarball_filename_fullpath}' '${TARBALL_FOLDER}/${new_filename}'" "Rebasing ${tarball} to ${new_filename}"
	doUse "${TARBALL_FOLDER}/${new_filename}"
}

function doInit() {
	header
	checkVars
	setOutputFolder

	case $command in
		list)
			doList
			;;
		use)
			doUse
			;;
		convert)
			doConvert
			;;
		export)
			doExport
			;;
		delete)
			doDelete
			;;
		rename)
			doRename
			;;
		rebase)
			doRebase
			;;
		help)
			usage
			;;
		*)
			usage
			exit 1
	esac
	exit 0
}

doInit

